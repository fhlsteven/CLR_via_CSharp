# 译者后记

从事软件开发的人，都是耐得住寂寞的人。Jeffery 不仅耐的住寂寞，还在自己专业玲领域取得了很高的造诣。取得了很高的造诣不说，他还愿意将自己的心得与大家分享。愿意和大家分享不说，他还非常实诚，真心想把自己的全部知识都清楚地交待给读者。字里行间，全是殷殷叮嘱。无浮夸之文字，倾心血而写就，近十年之所悟，尽呈现于本书。

读完这本书，你的心灵会受到极大的震撼。原因很简单，以前许多似懂非懂的概念，现在变得清晰明了；以前自以为是的做法，现在得到彻底纠正；以前艰苦摸索的编程技巧，现在如同 1+1 一样简单。

Jeffrey 最擅长的就是把最基本的东西将清楚。你以前或许知道 1+1 等于 2，但他会把 1+1 为什么等于 2 讲的明明白白。最终你会有一种顿悟的感觉，然后自动地知道 1+2 等于几，2+2 等于几。不需要翻阅其他书籍来查询结果。

本书基于《CLR via C#》第 3 版，在保持上一版精华内容的同时进行了大量修订，并添加了大量关于 C# 5.0 新特性的内容。翻译这一版的过程中，我对上一版也进行了精校和勘误，许多勘误和改进意见都是由热心读者提交的。在此对他们表示衷心感谢！他们包括但不限于：56xue Castor DamnnnSure JeffFan Jeffrey You Kenny Wang LuckyDogFace，Neil，Titus，charlesgeorge， dream-like， fanfan， frank ， hongkunjiang，huihui，kman，liu888bingsong，negy_liang，ooooo84，quark，sd，skyiv，wu，wukun0502，wzhou，yeahe83，北纬 49° 的雨，笨笨，不世出的 CLR 小白，大支豬舆小蘋果，何苦，来客心动，飘荡，飘飘白云，气象万千，千年一梦，如水的人生，施博，酸菜鱼，永远的阿哲

没有后期维护的书不算是好书。即使是本书英文原版，也维护了一份很长的勘误表，我本人也为其贡献良多。本书中文版将延续我一直以来坚持的风格，建立专门的页面进行维护，提供资源下载和勘误等服务。请大家继续前往我的博客(*[http://transbot.blog.163.com](http://transbot.blog.163.com)*)，发表关于本书的意见和建议。

本书翻译过程中，参与人员有柏红羽、陈绍云、成荣静、文天山、刁灿群、黄洁、江卫、蒋昌友、李建、刘其星、刘琼、刘勇、毛越龙、莫永红、文瑞、施玉梅、叶昌元、游美波、张攀飞和周建超。尤其要感谢我的乖女儿周子衿。人生的足迹，终于来到高中这一重要阶段，且行且珍惜。

最后，如同往常一样，我要说所有的功劳都要归于作者，所有的错误都要归于译者。欢迎大家批评指正。本书最后将列出我所采用的术语，以帮助大家进一步理解。

下表列出本书使用的一些术语，有异于 MSDN 文档(以后简称“文档”)的会专门指出。

|术语|说明|
|---|---|
|`(S)Byte`|等同于“`SByte`” 和 “`Byte`”，这是作者喜欢的说法。类似的还有`(U)Int16`，`(U)Int32`，`(U)IntPtr`等|
|AppDomain|(保留原文)|
|Compute-Bound 和 I/O-Bound|计算限制和I/O限制(一个操作如果因为处理器和 I/O 的限制而不得不等待，就称为计算限制或 I/O限制的操作)|
|Windows Store app|Windows Store 应用(文档中翻译成“Windows 应用商店应用”)，显得过于冗长|
|action method|操作方法|
|antecedent task 和 continuation task|前置任务和延续任务|
|arity|元数。在计算机编程中，一个函数或运算(操作)的元数是指函数获取的实参或操作数的个数。它源于像 unary(arity=1)、binary(arity=2)、ternary(arity=3)这样的单词|
|asynchronously synchronization|异步地同步(同步对资源的访问，但以异步方式进行，即不阻塞线程)|
|atomic|原子性(读或写都是一次完成，别的线程看不到中间状态，就说这种读写是原子性的)|
|attribute|特性(以文档为准)|
|awaiter|等待者(调用 GetAwaiter 所返回的对象)|
|bit flag|位标志|
|block|阻塞(停下来等着)|
|callback|回调(回调方法简称为“回调”)|
|calling thread|调用线程(发出调用的线程，也称主调线程)|
|capture|捕捉(文档中主要用“捕捉”，偶尔用“捕获”)|
|cast|转型(不用文档的“强制类型转换”是因为太冗长)|
|compact|压缩(但此压缩非彼压缩，这里只是按照约定俗成的方式将 compact 翻译成“压缩”。不要以为”压缩“后内存会增多。相反，这里的”压缩“更接近于”碎片整理“。但事实上，从上个世纪 80 年开始，人们就把它看成是 compress 的近义词而翻译成”压缩“，以讹传讹至今)|
|contract|文档的翻译非常混乱，包括协定、协议、合约、约定和契约等；本书使用”协定“|
|covariance 和 contravariance|协变和逆变(协变是指在要求使用一个类型的地方，能改为使用它的基类；逆变则是指在要求使用一个类型的地方，能改为使用它的派生类。C#用关键字 in 表示逆变量，用在输入位置；用 out 表示协变量，用在输出位置。详请参见 12.5 节)|
|culture|语言文化(而不是文档中的”区域性“)|
|cyclical reference|循环引用(我引用你，你引用我)|
|declarative|声明性(文档如此，个人更喜欢”宣告式“)|
|dispose|文档翻译成”释放“。但”dispose 一个对象“真正的意思是”清理或处置对象中包装的资源(比如它的字段引用的对象)，然后等着在一次垃圾回收之后回收该对象占用的托管堆内存(此时才释放)。“为避免误解，本书将 dispose 翻译成”清理“，偶尔也会保留原文。|
|entry|记录项(而不是”条目“、”入口“)|
|flush|文档翻译成”刷新“，本书保留原文。其实 flush 在技术文档中的意思和日常生活中一样，即"冲洗(到别处)"。例如，我们会说”冲水“，不会说”刷新水“|
|formatter|格式化器(文档是”格式化程序“)|
|get accessor method|get 访问器方法(取值函数或 getter)|
|guideline|设计规范|
|handler|处理程序。文档如此，个人不喜欢”程序“二字。|
|helper method|辅助方法|
|host|寄宿(动词)或宿主(名词)|
|invoke 和 call|都翻译成”调用“，但两者是有区别的。执行一个所有信息都已知的方法时，用 call 比较恰当。但在需要先”唤出“某个东西来帮你调用一个信息不明的方法时，用 invoke 就比较恰当。阅读关于委托和反射的章节时，可以更好地体会两者的区别|
|literal|直接在代码中书写的值就是 literal 值，比如字符串值和数值("Hello" 和 123)。翻译成什么的都有，包括直接量、字面值、文字常量、常量(台译)等。但实际最容易理解的还是英文原文。本书采用”字面值“|
|marshal|封送|
|metadata|元数据|
|mutex|互斥体|
|native method|本机方法(其实就是非托管方法)|
|native|本机(文档如此，个人更喜欢”原生“，比如原生类库、原生C/C++代码、原生堆。一切非托管的，就是 native 的)|
|operand|操作数(要操作/运算的目标)|
|operator|操作符(而不是文档中的”运算符“)|
|overload 和 override|重载和重写|
|preempt|抢占|
|primitive types|基元类型(文档如此，不是”基本类型“。可以在代码中使用的最简单的构造就称为”基元“，其他构造都是它们符合而成的)
|provider|提供程序(文档如此，个人不喜欢"程序"二字)|
|raise an event|引发事件|
|recursion count 和 recursive lock|递归计数和递归锁(可重入的锁就是递归锁，重入的次数就是递归计数)|
|scalability|伸缩性(在少量时间里做更多工作的能力，就是所谓的”伸缩性“。作为一个伸缩性好的服务器，理论上应该CPU越多，一个耗时操作所需的时间就越短。通俗地说，在多个 CPU 之间并行执行，执行时间将根据 CPU 的数量成比例地缩短)|
|self-hosted|自寄宿(应用程序的进程自己容纳CLR，就是所谓的自寄宿)|
|semaphore|信号量|
|set accessor method|set 访问器方法(赋值功函或 setter)|
|side effect|副作用|
|singleton|单实例(例如，如果某类型在每个 AppDomain 中只能有一个实例，它就是单实例类型)|
|spinning|自旋(线程不是阻塞，而是原地”打转“，浪费 CPU 时间。但在用于保护执行得非常快的代码区域时性能比较好)|
|string interning|字符串留用(而不是文档中的”字符串拘留“)|
|synchronous 和 asynchronous| 同步和异步(同步意味着一个操作开始后必须等待它完成；异步则意味着不用等它完成，可以立即返回做其他事情。不要将”同步“理解成”同时“)|
|tap(点击)，press and hold(长按)，slide(滑动)，swipe(轻扫)，turn(转动)，pinch(伸缩) 和 stretch(拉伸)|Windows 8 的各种触摸”手势“|
|throw an exception|抛出异常(而不是文档中的”引发异常“)|
|unwind|一般翻译成”展开“，但这并不是一个很好的翻译。wind 和 unwind 源于生活。把线缠到线圈上称为 wind；从线圈上松开称为 unwind。同样地，调用方法时压入栈桢，称为 wind；方法执行完毕，弹出栈桢，称为 unwind|
|volatile|易变(文档将 volatile 翻译成”可变“。其实它是”短暂存在“、”易变“的意思，因为可能有多个线程都对这种字段进行修改，本书采用"易变")|
|work item 和 worker thread|工作项和工作者线程(线程池术语。工作项是指要由一个线程池线程调用的方法，代表线程实际要做的工作；处理工作项的线程称为工作者线程。工作项被放到一个队列中，工作者线程将工作项从队列中取出并处理)|